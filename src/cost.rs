use crate::WindData;
use std::cmp::Ordering;
use tabular::{row, Table};

/// Wind power and natural gas: $ per KW capacity
/// source: https://proest.com/construction/cost-estimates/power-plants/
const WIND_DOLLAR_PER_KW: f64 = 1661.0;
const GAS_DOLLAR_PER_KW: f64 = 812.0;

/// plant lifetime in years: estimated
const WIND_LIFETIME_YEARS: f64 = 25.0;
const GAS_LIFETIME_YEARS: f64 = 25.0;

/// hours in a year
const HOURS_PER_YEAR: f64 = 365.24 * 24.0;

/// The amount of demand that's modelled: 300 GW, Europe's total electricity use
const DEMAND_GW: f64 = 300.0;
const BILLION: f64 = 1_000_000_000.0;

pub fn cost_main(wind_data: &WindData) {
    let mut table = Table::new("{:<}   {:<}   {:<}   {:<}   {:<}   {:<}   {:<}   {:<}");
    table.add_row(row!(
        "Gas price ($/MWh)",
        "Min cost wind cap. (GW)",
        "Total cost ($b/yr)",
        "Gas used (GW)",
        "Gas cap. req. (GW)",
        "Gas cap. factor (%)",
        "Wind pwr used (GW)",
        "Wind pwr percent (%)",
    ));
    // gas price in $/MWh
    for gas_price in [
        5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160,
        170, 180, 190, 200,
    ] {
        let best_wind_cap = find_lowest_cost_wind_capacity(wind_data, gas_price as f64);
        let cost = find_cost_per_year(wind_data, best_wind_cap, gas_price as f64);
        let (gas_used, gas_cap_required, wind_gw) = gas_and_wind_used(wind_data, best_wind_cap);
        let gas_cap_factor = gas_used / gas_cap_required * 100.0;
        let wind_percent = wind_gw / (wind_gw + gas_used) * 100.0;
        table.add_row(row!(
            format!("{:.2}", gas_price),
            format!("{:.2}", best_wind_cap),
            format!("{:.2}", cost / BILLION),
            format!("{:.2}", gas_used),
            format!("{:.2}", gas_cap_required),
            format!("{:.2}", gas_cap_factor),
            format!("{:.2}", wind_gw),
            format!("{:.2}", wind_percent),
        ));
    }
    println!("{}", table);
}

fn find_lowest_cost_wind_capacity(wind_data: &WindData, gas_price_mwh: f64) -> f64 {
    // this finds the minimum of a function if it only has one inflection point (which this does)
    let mut lower_limit: f64 = 0.0;
    let mut upper_limit: f64 = 100_000.0;
    while (upper_limit - lower_limit).abs() > 0.001 {
        let mid_low = lower_limit + (upper_limit - lower_limit) / 3.0;
        let mid_low_cost = find_cost_per_year(wind_data, mid_low, gas_price_mwh);
        let mid_high = lower_limit + (upper_limit - lower_limit) * 2.0 / 3.0;
        let mid_high_cost = find_cost_per_year(wind_data, mid_high, gas_price_mwh);
        if mid_low_cost < mid_high_cost {
            // minimum cannot be between mid_high and upper
            upper_limit = mid_high;
        } else {
            // minimum cannot be between mid_low and lower
            lower_limit = mid_low;
        }
    }
    (upper_limit + lower_limit) / 2.0
}

fn find_cost_per_year(wind_data: &WindData, wind_capacity: f64, gas_price_mwh: f64) -> f64 {
    // calculate the total cost of the wind turbines: the scaled capacity in the wind data
    // multiplied by the cost per GW, divided by the turbine lifetime to give a cost per year.
    let wind_turbine_cost_per_year =
        wind_capacity * (WIND_DOLLAR_PER_KW * 1_000_000.0 / WIND_LIFETIME_YEARS);

    // calculate the cost of the required gas turbines: the backup gas capacity that was required
    // multiplied by the cost per GW of gas plant, divided by the plant lifetime to give per year
    let (gas_average_gw, gas_capacity_req_gw, _) = gas_and_wind_used(wind_data, wind_capacity);
    let gas_turbine_cost_per_year =
        gas_capacity_req_gw * (GAS_DOLLAR_PER_KW * 1_000_000.0 / GAS_LIFETIME_YEARS);

    // and the cost of the amount of actual gas used per year
    let fuel_cost_per_year = gas_average_gw * HOURS_PER_YEAR * (gas_price_mwh * 1000.0);

    // giving a total price per year
    wind_turbine_cost_per_year + gas_turbine_cost_per_year + fuel_cost_per_year
}

/// For a given wind data, and a total installed wind capacity, returns:
/// - the average power generated by gas (GW)
/// - the maximum amount of power generated by gas over the sample (GW)
/// - the average power generated by wind (GW)  
fn gas_and_wind_used(wind_data: &WindData, wind_capacity: f64) -> (f64, f64, f64) {
    // how much we should scale wind_data by to get an output appropriate for the wind_capacity
    let wind_scale = wind_capacity / wind_data.total_capacity_gw;

    // simulate using the wind power data
    let mut gas_gwh: f64 = 0.0;
    let mut gas_max_gw: f64 = 0.0;
    let mut wind_gwh: f64 = 0.0;
    for (_, base_wind_gw) in &wind_data.output_gw {
        let wind_output_gw = base_wind_gw * wind_scale;
        if wind_output_gw < DEMAND_GW {
            // we don't have enough wind output so must use gas as backup
            let gas_gw = DEMAND_GW - wind_output_gw;
            gas_gwh += gas_gw;
            gas_max_gw = gas_max_gw.max(gas_gw);
            wind_gwh += wind_output_gw;
        } else {
            // we have enough to meet demand, so don't need to use any gas
            wind_gwh += DEMAND_GW;
        }
    }
    let samples = wind_data.output_gw.len() as f64;
    let gas_average_gw = gas_gwh / samples;
    let wind_average_gw = wind_gwh / samples;
    (gas_average_gw, gas_max_gw, wind_average_gw)
}
